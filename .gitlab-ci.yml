stages:
  - build
  - deploy

.build-docker-web:
  stage: build
  image: docker:19.03.15
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY --username $CI_REGISTRY_USER --password-stdin
  script:
    - cd payment-client
    # Pull and build the latest builder image.
    - docker image pull $GFMIS_REGISTRY_IMAGE:builder || true
    - docker build
      --target builder
      --cache-from $GFMIS_REGISTRY_IMAGE:builder
      -t $GFMIS_REGISTRY_IMAGE:builder .
    # Pull and build the latest runtime image.
    - docker image pull $GFMIS_REGISTRY_IMAGE:latest || true
    - docker build
      --cache-from $GFMIS_REGISTRY_IMAGE:builder
      --cache-from $GFMIS_REGISTRY_IMAGE:latest
      -t $GFMIS_REGISTRY_IMAGE:latest .
    # Push runtime images
    - docker push $GFMIS_REGISTRY_IMAGE:latest
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        docker image tag $GFMIS_REGISTRY_IMAGE:latest $GFMIS_REGISTRY_IMAGE:$CI_COMMIT_TAG
        docker image push $GFMIS_REGISTRY_IMAGE:$CI_COMMIT_TAG
      fi
    # Push builder images for next build
    - docker push $GFMIS_REGISTRY_IMAGE:builder || true
  tags:
    - docker

.build-docker-api:
  stage: build
  image: docker:19.03.15
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY --username $CI_REGISTRY_USER --password-stdin
  script:
    - cd payment-service
    # Pull and build the latest m2builder image.
    - docker image pull $GFMIS_REGISTRY_IMAGE:m2builder || true
    - docker build
      --target m2builder
      --cache-from $GFMIS_REGISTRY_IMAGE:m2builder
      -t $GFMIS_REGISTRY_IMAGE:m2builder .
    # Pull and build the latest builder image.
    - docker image pull $GFMIS_REGISTRY_IMAGE:builder || true
    - docker build
      --target builder
      --cache-from $GFMIS_REGISTRY_IMAGE:m2builder
      --cache-from $GFMIS_REGISTRY_IMAGE:builder
      -t $GFMIS_REGISTRY_IMAGE:builder .
    # Pull and build the latest runtime image using all previous cache layers.
    - docker image pull $GFMIS_REGISTRY_IMAGE:latest || true
    - docker build
      --cache-from $GFMIS_REGISTRY_IMAGE:m2builder
      --cache-from $GFMIS_REGISTRY_IMAGE:builder
      --cache-from $GFMIS_REGISTRY_IMAGE:latest
      -t $GFMIS_REGISTRY_IMAGE:latest .
    # Push runtime images
    - docker image push $GFMIS_REGISTRY_IMAGE:latest
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        docker image tag $GFMIS_REGISTRY_IMAGE:latest $GFMIS_REGISTRY_IMAGE:$CI_COMMIT_TAG
        docker image push $GFMIS_REGISTRY_IMAGE:$CI_COMMIT_TAG
      fi
    # Push builder images for next build
    - docker image push $GFMIS_REGISTRY_IMAGE:m2builder || true
    - docker image push $GFMIS_REGISTRY_IMAGE:builder || true
  tags:
    - docker

build-docker-web-master:
  extends: .build-docker-web
  variables:
    GFMIS_REGISTRY_IMAGE: $CI_REGISTRY_IMAGE/payment_web
  rules:
    - if: $CI_COMMIT_REF_NAME == "master"
      when: always
    - if: $CI_COMMIT_TAG != null && $CI_COMMIT_TAG =~ /^v\d+.\d+.\d+.*$/
      when: always
    - when: never

build-docker-api-master:
  extends: .build-docker-api
  variables:
    GFMIS_REGISTRY_IMAGE: $CI_REGISTRY_IMAGE/payment_api
  rules:
    - if: $CI_COMMIT_REF_NAME == "master"
      when: always
    - if: $CI_COMMIT_TAG != null && $CI_COMMIT_TAG =~ /^v\d+.\d+.\d+.*$/
      when: always
    - when: never

deploy-to-dev:
  stage: deploy
  image: bitnami/git:2.31.1
  environment: DEV
  before_script:
    # Download and install jq binary
    - 'curl -s -S -L -o /usr/local/bin/jq --header "JOB-TOKEN: $CI_JOB_TOKEN" ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/jq/1.6/jq-linux64'
    - chmod +x /usr/local/bin/jq
  script:
    # Clone project dev-deployment
    - git clone --branch master --depth 1 "https://project-access-token:$GF_PROJ_DEPLOYMENT_TOKEN@${CI_SERVER_HOST}/deployment/dev-deployment.git"
    - cd dev-deployment
    # Immediately exit if version already exists
    - if [ "$CI_COMMIT_TAG" == "$(grep CENTRAL_PAYMENT_API_IMAGE_TAG central-payment.version | cut -d= -f2)" ]; then exit; fi
    # Configure required personla information before pushing
    - git config user.email "$GITLAB_USER_EMAIL"
    - git config user.name "$GITLAB_USER_NAME"
    - sed -i -E "s/(CENTRAL_PAYMENT_API_IMAGE_TAG)=.*/\1=${CI_COMMIT_TAG}/" central-payment.version
    - sed -i -E "s/(CENTRAL_PAYMENT_WEB_IMAGE_TAG)=.*/\1=${CI_COMMIT_TAG}/" central-payment.version
    - cat central-payment.version
    - git commit -a -m "update central-payment.version to $CI_COMMIT_TAG"
    - git push
    # Get most recent commit SHA
    - GF_COMMIT_SHA=$(git rev-parse HEAD)
    # Wait for dev-deployment pipeline jobs be created
    - sleep 10
    # Get pipeline id based on commit SHA
    - 'GF_PIPELINE_ID=$(curl --silent --header "PRIVATE-TOKEN: $GF_PROJ_DEPLOYMENT_TOKEN" "${CI_API_V4_URL}/projects/deployment%2Fdev-deployment/pipelines?sha=$GF_COMMIT_SHA" | jq ''.[0] .id'')'
    # Get job id from given pipeline id and filter with job name
    - 'GF_JOB_ID=$(curl --silent --header "PRIVATE-TOKEN: $GF_PROJ_DEPLOYMENT_TOKEN" "${CI_API_V4_URL}/projects/deployment%2Fdev-deployment/pipelines/$GF_PIPELINE_ID/jobs" | jq ''.[] | select(.name == "deploy_central_payment") | .id'')'
    # Execute job for deployment
    - 'curl --silent --request POST --header "PRIVATE-TOKEN: $GF_PROJ_DEPLOYMENT_TOKEN" "${CI_API_V4_URL}/projects/deployment%2Fdev-deployment/jobs/$GF_JOB_ID/play"'
  rules:
    - if: $CI_COMMIT_TAG != null && $CI_COMMIT_TAG =~ /^v\d+.\d+.\d+.*$/
      when: on_success
    - when: never
  allow_failure: true
  tags:
    - docker
